/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package myapp.model;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;

public class ProductRepository {
    private Connection conn;

    public ProductRepository(Connection conn) {
        this.conn = conn;
    }

    public Product findById(int id) throws SQLException {
        Product product = null;

        String sql = "select * from product where id = ?";
        PreparedStatement pstmt = conn.prepareStatement(sql); // 인젝션 공격을 당하지 않음, 바인딩하기 편함

        // 3. 물음표 완성
        pstmt.setInt(1, id);// (물음표의 순서, 이름)

        // 4. 전송
        ResultSet rs = pstmt.executeQuery();
        if (rs.next()) {// 커서를 한칸 내리고, 행이 있는지 확인해줌
            int v1 = rs.getInt("id");
            String name = rs.getString("name");
            int price = rs.getInt("price");
            int qty = rs.getInt("qty");
            Timestamp createdAt = rs.getTimestamp("created_at");
            product = new Product(v1, name, price, qty, createdAt);
        } // 매핑해서 값 넣어줌 -> 매퍼(마이바티스 역활)
        return product;
    }

    public List<Product> findAll() throws SQLException {
        List<Product> productList = new ArrayList<>();

        // 2. 버퍼 접근
        String sql = "select * from product";
        PreparedStatement pstmt = conn.prepareStatement(sql);

        // 3. 전송
        ResultSet rs = pstmt.executeQuery();
        while (rs.next()) {
            int id = rs.getInt("id");
            String name = rs.getString("name");
            int price = rs.getInt("price");
            int qty = rs.getInt("qty");
            Timestamp createdAt = rs.getTimestamp("created_at");
            Product product = new Product(id, name, price, qty, createdAt);
            productList.add(product);
        }
        return productList;
    }

    public void insert(String name, int price, int qty) throws SQLException {

        String sql = "insert into product(name, price, qty, created_at) values(?,?,?,now())";
        PreparedStatement pstmt = conn.prepareStatement(sql); // 인젝션 공격을 당하지 않음, 바인딩하기 편함

        // 3. 물음표 완성
        pstmt.setString(1, name);// (물음표의 순서, 이름)
        pstmt.setInt(2, price);
        pstmt.setInt(3, qty);

        // 4. 전송
        // pstmt.addBatch(sql); //batch 메모리에 모아놓고 한번에 전송
        int result = pstmt.executeUpdate();

        // 5. 응답에 대한 처리
        if (result == 1) {
            System.out.println("insert 되었습니다");
        } else {
            System.out.println("insert 실패");
        }

        // 6. 최종마무리
        pstmt.close();

    }

    public void deleteById(int id) throws SQLException {

        String sql = "delete from product where id = ?";
        PreparedStatement pstmt = conn.prepareStatement(sql); // 인젝션 공격을 당하지 않음, 바인딩하기 편함

        pstmt.setInt(1, id);// (물음표의 순서, 이름)

        // 4. 전송
        // pstmt.addBatch(sql); //batch 메모리에 모아놓고 한번에 전송
        int result = pstmt.executeUpdate();

        // 5. 응답에 대한 처리
        if (result == 1) {
            System.out.println("delete 되었습니다");
        } else {
            System.out.println("delete 실패");
        }
        // 6. 최종마무리
        pstmt.close();

    }

    public void updateById(int id, String name, int price, int qty) throws SQLException {

        String sql = "update product set name=?, price=?, qty=? where id = ?";
        PreparedStatement pstmt = conn.prepareStatement(sql); // 인젝션 공격을 당하지 않음, 바인딩하기 편함

        pstmt.setString(1, name);// (물음표의 순서, 이름)
        pstmt.setInt(2, price);// (물음표의 순서, 이름)
        pstmt.setInt(3, qty);// (물음표의 순서, 이름)
        pstmt.setInt(4, id);// (물음표의 순서, 이름)

        // 4. 전송
        // pstmt.addBatch(sql); //batch 메모리에 모아놓고 한번에 전송
        int result = pstmt.executeUpdate();

        // 5. 응답에 대한 처리
        if (result == 1) {
            System.out.println("update 되었습니다");
        } else {
            System.out.println("update 실패");
        }
        // 6. 최종마무리
        pstmt.close();

    }
}
